<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Minimum Spanning Tree</title>
    <link rel="stylesheet" href="style.css" type="text/css">
  </head>
  <body>
    <div id="root">
        <h1>Team Ctrl Alt Dlt</h1>
        <h2>Team members:</h2>
        Marima Fatima<br>Ramisa Tahsin Rahman<br>Sulagna Saha
    </div>
    <h2>Topic: Minimum Spanning Tree</h2>
    <div id="explanation">
        <p>Minimum spanning tree(mst) is a tree in a graph that connects all the vertices together with the minimum possible total edge weight. 
        It is a subgraph of the original graph. It is used in many applications such as network design, circuit design, clustering, etc.
        MST application goes beyond computer science such as fintech, economics, chemistry, etc. Some applications that motivated us to work on MST are: 
    <ul>
        <li>It is used in network design to find the most efficient way to connect nodes in a network while minimizing the cost of constructing the connections.</li>
        <li>In the finance industry, risk managers can identify potential sources of systemic risk and take measures to mitigate them.</li>
        <li>It's a fundamental tool in solving optimization problem. </li>
    </ul>
    <strong>Purpose: Demonstrate deriving MST from a given graph using Prim & Kruskal's algorithm.</strong>
    <br><br><strong>Prim's Algorithm:</strong>
    <p>Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. 
    <br>The algorithm operates by building this tree one vertex at a time, starting from an arbitrary starting vertex(chosen by user), at each step adding the cheapest possible connection from the tree to another vertex.</p>
    
    <strong>Kruskal's Algorithm:</strong>
    <p>Kruskal's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. 
        It finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized.
        It sorts the edges by weight and progressively adds them to the growing forest, taking care not to add any edges that would create a cycle.
    </p>
    <button id="interactive" onclick="window.location.href='interactive.html'">Go to interactive page</button>
    <h3>Techincal Development of our website:</h3>
    <p>
        We used HTML, CSS, Javascript to develop our website. We used HTML to create the skeleton of the website, CSS to style the website & Javascript to implement the algorithms.  
        We used the following data structures to implement the algorithms: 
        <ul>
            <li>Adjacency List to keep note of the neighbors of the vertices.</li>
            <li>Priority Queue using minheap.</li>
            <li>Set to keep track of visited vertices.</li>
            <li>Breadth First Search(BFS) to detect a cycle </li>
        </ul>
   
    <h3>References:</h3>
    <ul>
        <li> <a href="https://www.tutorialspoint.com/The-PriorityQueue-Class-in-Javascript">The-PriorityQueue-Class-in-Javascript</a></li>
        <li> <a href= "https://www.cs.usfca.edu/~galles/visualization/Prim.html">Prim's Algorithm Visualization</a></li>
        <li> <a href="https://www.cs.usfca.edu/~galles/visualization/Kruskal.html">Kruskal's Algorithm Visualization</a></li>
    </ul>
    </div>
  </body>
</html>
